package common

import (
	"github.com/aws/aws-sdk-go/service/kms"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/aws/credentials/stscreds"
	"github.com/aws/aws-sdk-go/aws"
	"time"
	"encoding/json"
	"log"
	"encoding/base64"
	"github.com/aws/aws-sdk-go/service/sts"
	"strings"
	"golang.org/x/crypto/ssh"
	"fmt"
	"github.com/pkg/errors"
	"crypto/rand"
)

func SignSsh(caKeyBytes, userPubkeyBytes []byte, durationSecs int64, keyId string, principals []string) (*string, error) {
	signer, err := ssh.ParsePrivateKey(caKeyBytes)
	if err != nil {
		return nil, errors.Wrap(err, "err parsing ca priv key")
	}

	userPubkey, _, _, _, err := ssh.ParseAuthorizedKey(userPubkeyBytes)
	if err != nil {
		return nil, errors.Wrap(err, "err parsing user pub key")
	}

	now := time.Now()
	after := now.Add(-300 * time.Second)
	before := now.Add(time.Duration(durationSecs) * time.Second)

	cert := &ssh.Certificate{
		//Nonce: is generated by cert.SignCert
		Key: userPubkey,
		Serial: 0,
		CertType: ssh.UserCert,
		KeyId: keyId,
		ValidPrincipals: principals,
		ValidAfter: uint64(after.Unix()),
		ValidBefore: uint64(before.Unix()),
		Permissions: ssh.Permissions{
			CriticalOptions: map[string]string{},
			Extensions: map[string]string{
				"permit-X11-forwarding":   "",
				"permit-agent-forwarding": "",
				"permit-port-forwarding":  "",
				"permit-pty":              "",
				"permit-user-rc":          "",
			},
		},
		Reserved: []byte{},
	}

	randSource := rand.Reader
	err = cert.SignCert(randSource, signer)
	if err != nil {
		return nil, errors.Wrap(err, "err signing cert")
	}

	signed := cert.Marshal()

	b64 := base64.StdEncoding.EncodeToString(signed)
	formatted := fmt.Sprintf("%s %s", cert.Type(), b64)
	return &formatted, nil
}

func AwsSession(profile, region string) *session.Session {
	sessOpts := session.Options{
		SharedConfigState: session.SharedConfigEnable,
		AssumeRoleTokenProvider: stscreds.StdinTokenProvider,
	}

	if len(profile) > 0 {
		sessOpts.Profile = profile
	}

	sess, _ := session.NewSessionWithOptions(sessOpts)
	config := aws.NewConfig()

	if len(region) > 0 {
		config.Region = aws.String(region)
		sess.Config = config
	}

	return sess
}

type PlaintextPayload struct {
	NotBefore float64 // this is what json.unmarshal wants
	NotAfter float64
}

func CreateToken(client *kms.KMS, key, from, to, principal string) string {
	context := make(map[string]*string)
	context["from"] = &from
	context["to"] = &to
	context["type"] = &principal

	now := float64(time.Now().Unix())
	end := now + 3600 // 1 hour

	payload := PlaintextPayload{
		NotBefore: now,
		NotAfter: end,
	}

	plaintext, err := json.Marshal(&payload)
	if err != nil {
		log.Panicf("Payload json encoding error: %s", err.Error())
	}

	input := &kms.EncryptInput{
		Plaintext: plaintext,
		KeyId: aws.String(key),
		EncryptionContext: context,
	}

	response, err := client.Encrypt(input)
	if err != nil {
		log.Panicf("Encrytion error: %s", err.Error())
	}

	blob := response.CiphertextBlob
	return base64.StdEncoding.EncodeToString(blob)
}

func ValidateToken(client *kms.KMS, key, from, to, principal, token string) string {
	context := make(map[string]*string)
	context["from"] = &from
	context["to"] = &to
	context["type"] = &principal

	binary, err := base64.StdEncoding.DecodeString(token)
	if err != nil {
		log.Panicf("Token base64 decoding error: %s", err.Error())
	}

	input := &kms.DecryptInput{
		CiphertextBlob: binary,
		EncryptionContext: context,
	}

	response, err := client.Decrypt(input)
	if err != nil {
		log.Panicf("Decryption error: %s", err.Error())
	}

	resolvedKey, err := resolvedKeyArn(client, key)
	if err != nil {
		log.Panicf("Couldn't determine key arn: %s", err.Error())
	}

	if *resolvedKey != *response.KeyId {
		log.Panicf("Mismatching KMS key ids: %s and %s", *resolvedKey, *response.KeyId)
	}

	return string(response.Plaintext)
}

func resolvedKeyArn(client *kms.KMS, key string) (*string, error) {
	if strings.HasPrefix(key, "arn:aws:kms:") {
		return &key, nil
	}

	input := &kms.DescribeKeyInput{
		KeyId: &key,
	}

	response, err := client.DescribeKey(input)

	if response != nil {
		return response.KeyMetadata.Arn, err
	} else {
		return nil, err
	}
}

func CallerIdentityUser(client *sts.STS) (*string, error) {
	response, err := client.GetCallerIdentity(&sts.GetCallerIdentityInput{})

	if err == nil {
		arn := *response.Arn
		parts := strings.SplitN(arn, "/", 2)
		return &parts[1], nil
	} else {
		return nil, err
	}
}