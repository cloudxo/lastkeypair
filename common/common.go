package common

import (
	"github.com/aws/aws-sdk-go/service/kms"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/aws/credentials/stscreds"
	"github.com/aws/aws-sdk-go/aws"
	"time"
	"encoding/json"
	"log"
	"encoding/base64"
	"github.com/aws/aws-sdk-go/service/sts"
	"strings"
	"golang.org/x/crypto/ssh"
	"fmt"
	"github.com/pkg/errors"
	"crypto/rand"
	"github.com/aws/aws-sdk-go/aws/request"
)

var ApplicationVersion string
var ApplicationBuildDate string

var DefaultSshPermissions = ssh.Permissions{
	CriticalOptions: map[string]string{},
	Extensions: map[string]string{
		"permit-X11-forwarding":   "",
		"permit-agent-forwarding": "",
		"permit-port-forwarding":  "",
		"permit-pty":              "",
		"permit-user-rc":          "",
	},
}

func SignSsh(caKeyBytes, pubkeyBytes []byte, certType uint32, expiry uint64, permissions ssh.Permissions, keyId string, principals []string) (*string, error) {
	signer, err := ssh.ParsePrivateKey(caKeyBytes)
	if err != nil {
		return nil, errors.Wrap(err, "err parsing ca priv key")
	}

	userPubkey, _, _, _, err := ssh.ParseAuthorizedKey(pubkeyBytes)
	if err != nil {
		return nil, errors.Wrap(err, "err parsing user pub key")
	}

	now := time.Now()
	after := now.Add(-300 * time.Second)

	cert := &ssh.Certificate{
		//Nonce: is generated by cert.SignCert
		Key: userPubkey,
		Serial: 0,
		CertType: certType,
		KeyId: keyId,
		ValidPrincipals: principals,
		ValidAfter: uint64(after.Unix()),
		ValidBefore: expiry,
		Permissions: permissions,
		Reserved: []byte{},
	}

	randSource := rand.Reader
	err = cert.SignCert(randSource, signer)
	if err != nil {
		return nil, errors.Wrap(err, "err signing cert")
	}

	signed := cert.Marshal()

	b64 := base64.StdEncoding.EncodeToString(signed)
	formatted := fmt.Sprintf("%s %s", cert.Type(), b64)
	return &formatted, nil
}

func AwsSession(profile, region string) *session.Session {
	sessOpts := session.Options{
		SharedConfigState: session.SharedConfigEnable,
		AssumeRoleTokenProvider: stscreds.StdinTokenProvider,
	}

	if len(profile) > 0 {
		sessOpts.Profile = profile
	}

	sess, _ := session.NewSessionWithOptions(sessOpts)
	config := aws.NewConfig()

	userAgentHandler := request.NamedHandler{
		Name: "LastKeypair.UserAgentHandler",
		Fn:   request.MakeAddToUserAgentHandler("LastKeypair", ApplicationVersion),
	}
	sess.Handlers.Build.PushBackNamed(userAgentHandler)

	if len(region) > 0 {
		config.Region = aws.String(region)
		sess.Config = config
	}

	return sess
}

type PlaintextPayload struct {
	NotBefore float64 // this is what json.unmarshal wants
	NotAfter float64
}

type TokenParams struct {
	FromId string
	FromAccount string
	To string
	Type string

	// optional fields below this comment
	FromName string `json:",omitempty"`
	Vouchee string `json:",omitempty"`
	Context string `json:",omitempty"`
	Vouchers []VoucherToken `json:",omitempty"`

	// the reason we have both these fields (rather than overloading one "InstanceArn" field)
	// is because we want to specify a KMS key policy that HostInstanceArn _MUST_ match
	// the ec2:SourceInstanceARN if it exists. if we didn't do this, then anyone _not_ on
	// an instance could request a host cert.
	HostInstanceArn   string `json:",omitempty"` // this field is for when an instance is requesting a host cert
	RemoteInstanceArn string `json:",omitempty"` // this field is for when a user is requesting a user cert for a specific host

	SshUsername string `json:",omitempty"` // username on remote instance that user wants to access
}

func (params *TokenParams) ToKmsContext() map[string]*string {
	iterateParams := func(p *TokenParams, cb func(string, *string)) {
		cb("fromId", &p.FromId)
		cb("fromAccount", &p.FromAccount)
		cb("to", &p.To)
		cb("type", &p.Type)

		if len(p.FromName) > 0 {
			cb("fromName", &p.FromName)
		}

		if len(p.HostInstanceArn) > 0 {
			cb("hostInstanceArn", &p.HostInstanceArn)
		}

		if len(p.RemoteInstanceArn) > 0 {
			cb("remoteInstanceArn", &p.RemoteInstanceArn)
		}

		if len(p.SshUsername) > 0 {
			cb("sshUsername", &p.SshUsername)
		}

		if len(p.Vouchee) > 0 {
			cb("vouchee", &p.Vouchee)
		}

		if len(p.Context) > 0 {
			cb("context", &p.Context)
		}
	}

	context := make(map[string]*string)
	iterateParams(params, func(key string, val *string) {
		context[key] = val
	})

	if len(params.Vouchers) > 0 {
		for i, v := range(params.Vouchers) {
			keyPrefix := fmt.Sprintf("voucher-%d-", i)

			iterateParams(&v.Params, func(key string, val *string) {
				context[keyPrefix + key] = val
			})
		}
	}

	return context
}

type Token struct {
	Params TokenParams
	Signature []byte
}

func kmsClientForKeyId(sess *session.Session, keyId string) *kms.KMS {
	if strings.HasPrefix(keyId, "arn:aws:kms") {
		parts := strings.Split(keyId, ":")
		region := parts[3]
		sess = sess.Copy(aws.NewConfig().WithRegion(region))
	}

	return kms.New(sess)
}

func CreateToken(sess *session.Session, params TokenParams, keyId string) Token {
	context := params.ToKmsContext()

	now := float64(time.Now().Unix())
	end := now + 3600 // 1 hour

	payload := PlaintextPayload{
		NotBefore: now,
		NotAfter: end,
	}

	plaintext, err := json.Marshal(&payload)
	if err != nil {
		log.Panicf("Payload json encoding error: %s", err.Error())
	}

	input := &kms.EncryptInput{
		Plaintext: plaintext,
		KeyId: &keyId,
		EncryptionContext: context,
	}

	client := kmsClientForKeyId(sess, keyId)
	response, err := client.Encrypt(input)
	if err != nil {
		log.Panicf("Encrytion error: %s", err.Error())
	}

	blob := response.CiphertextBlob
	return Token{Params: params, Signature: blob}
}

func ValidateToken(sess *session.Session, token Token, expectedKeyId string) bool {
	context := token.Params.ToKmsContext()

	input := &kms.DecryptInput{
		CiphertextBlob: token.Signature,
		EncryptionContext: context,
	}

	client := kms.New(sess)
	response, err := client.Decrypt(input)
	if err != nil {
		log.Panicf("Decryption error: %s", err.Error())
	}

	/* We verify that the encryption key used is the one that we expected it to be.
	   This is very important, as an attacker could submit ciphertext encrypted with
	   a key they control that grants our Lambda permission to decrypt. Perhaps it
	   would be worth implementing some kind of alert here?
	 */
	if expectedKeyId != *response.KeyId {
		log.Panicf("Mismatching KMS key ids: %s and %s", expectedKeyId, *response.KeyId)
	}

	payload := PlaintextPayload{}
	err = json.Unmarshal([]byte(response.Plaintext), &payload)
	if err != nil {
		return false
		//return nil, errors.Wrap(err, "decoding token json")
	}

	now := float64(time.Now().Unix())
	if now < payload.NotBefore || now > payload.NotAfter {
		return false
		//return nil, errors.New("expired token")
	}

	return true
}

type StsIdentity struct {
	AccountId string
	UserId string
	Username string
	Type string
}

func CallerIdentityUser(sess *session.Session) (*StsIdentity, error) {
	client := sts.New(sess)
	response, err := client.GetCallerIdentity(&sts.GetCallerIdentityInput{})

	if err == nil {
		arn := *response.Arn
		parts := strings.SplitN(arn, ":", 6)

		if strings.HasPrefix(parts[5], "user/") {
			name := parts[5][5:]
			return &StsIdentity{
				AccountId: *response.Account,
				UserId: *response.UserId,
				Username: name,
				Type: "User",
			}, nil
		} else if strings.HasPrefix(parts[5], "assumed-role/") {
			return &StsIdentity{
				AccountId: *response.Account,
				UserId: *response.UserId,
				Username: "",
				Type: "AssumedRole",
			}, nil
		} else {
			return nil, errors.New("unsupported IAM identity type")
		}
	} else {
		return nil, err
	}
}